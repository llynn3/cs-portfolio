# cs-portfolio

In these projects, I worked on building and analyzing different data structures and algorithms. The main problem I solved was creating a program that organizes and displays computer-science courses efficiently. Understanding runtime and memory helped me decide which data structure was best for sorting and searching — in this case, the Binary Search Tree gave a good balance of speed and simplicity.

When I ran into issues, especially with code setup and file handling, I used debugging, print statements, and research to fix them. I also practiced patience and broke the tasks into smaller steps until everything worked.

These projects really helped me understand how data structures impact performance and readability. I’ve started writing programs that are cleaner, easier to read, and more flexible if I need to update them later. It made me realize that maintainable code is just as important as working code.






This portfolio entry highlights my work in software testing, automation, and quality assurance. The artifacts I included from this course demonstrate my ability to write effective unit tests, identify and fix bugs, and ensure software meets user requirements. From Project One, I included the Contact Service Java files (Contact.java, ContactService.java, ContactTest.java, and ContactServiceTest.java). From Project Two, I included my Summary and Reflections Report. Together, these artifacts represent my growth as a software engineer and tester.

How can I ensure that my code, program, or software is functional and secure?

I ensure my code is functional and secure by writing unit tests that validate each component individually before integration. Using JUnit, I tested both valid and invalid inputs to make sure the application handled data safely and correctly. I also followed best practices like input validation, avoiding hardcoded data, and using clear exception handling to prevent potential vulnerabilities. Functional testing helped confirm that every method performed as intended, while automated testing ensured consistent and repeatable results.

How do I interpret user needs and incorporate them into a program?

I interpret user needs by reviewing software requirements and transforming them into testable features. In the Contact Service project, for example, I focused on what users needed most—accurate contact management with data validation. I then wrote my classes and tests around those expectations, ensuring that users couldn’t create invalid contacts or exceed field limits. By thinking from the end-user perspective and following requirement documents, I was able to create software that aligns with both usability and quality goals.

How do I approach designing software?

My approach to designing software begins with planning, modularization, and testing early. I break down requirements into smaller methods or classes that can be developed and tested independently. I apply principles of object-oriented programming to keep my code maintainable and reusable. For testing, I follow a test-driven mindset, meaning I think about how to prove a feature works before or while building it. This ensures my final design is efficient, readable, and easier to maintain over time.

Reflection

This course helped me strengthen my technical confidence in testing and debugging code. By creating automated JUnit tests, I learned how to uncover hidden errors and improve reliability before deployment. More importantly, I gained an appreciation for quality assurance as a continuous process, not just a final step. Adding these projects to my portfolio allows me to show potential employers that I understand both the engineering and testing sides of software development.
